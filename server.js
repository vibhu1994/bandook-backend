require('dotenv').config();

const express = require('express');
const axios = require('axios');
const cors = require('cors');
const fs = require('fs');
const path = require('path');

const app = express();
const PORT = process.env.PORT || 5000;

// ==== FILE PATHS ====
const DIALOGUES_FILE = path.join(__dirname, 'dialogues.json');
const TOKENS_FILE = path.join(__dirname, 'tokens.json');

// ==== GLOBALS ====
let dialogues = [];
let defaultDescription = "Activity name auto generated by BandookDotCom - give your activities the names they need, but maybe not deserve";

const defaultActivityNames = [
  "Morning Run", "Evening Run", "Run", "Workout", "Ride",
  "Evening Ride", "Afternoon Run", "Afternoon Ride", "Run Endurance",
  "Race", "Training", "Long Ride"
];

// ==== LOAD/SAVE DIALOGUES ====
function loadDialogues() {
  try {
    const data = fs.readFileSync(DIALOGUES_FILE, 'utf-8');
    dialogues = JSON.parse(data);
    console.log(`Loaded ${dialogues.length} dialogues`);
  } catch (err) {
    console.error('Failed to load dialogues file:', err);
    dialogues = [];
  }
}

function saveDialogues() {
  try {
    fs.writeFileSync(DIALOGUES_FILE, JSON.stringify(dialogues, null, 2), 'utf-8');
  } catch (err) {
    console.error('Failed to save dialogues:', err);
  }
}

loadDialogues();

// ==== TOKEN AUTO-REFRESH + SAVE ====
function loadTokens() {
  try {
    const data = fs.readFileSync(TOKENS_FILE, 'utf-8');
    return JSON.parse(data);
  } catch (err) {
    console.error('Failed to load tokens:', err);
    return null;
  }
}

function saveTokens(tokens) {
  try {
    fs.writeFileSync(TOKENS_FILE, JSON.stringify(tokens, null, 2), 'utf-8');
  } catch (err) {
    console.error('Failed to save tokens:', err);
  }
}

async function getFreshAccessToken() {
  let tokens = loadTokens();
  if (!tokens) throw new Error('tokens.json missing or invalid! Complete OAuth first.');

  const now = Math.floor(Date.now() / 1000);
  // Refresh if expires within 2 minutes
  if (tokens.expires_at && tokens.expires_at - now < 120) {
    console.log('Access token expired or near expiry — refreshing...');
    const resp = await axios.post('https://www.strava.com/oauth/token', null, {
      params: {
        client_id: process.env.STRAVA_CLIENT_ID,
        client_secret: process.env.STRAVA_CLIENT_SECRET,
        grant_type: 'refresh_token',
        refresh_token: tokens.refresh_token
      }
    });
    // Save refreshed
    tokens.access_token = resp.data.access_token;
    tokens.refresh_token = resp.data.refresh_token;
    tokens.expires_at = resp.data.expires_at;
    saveTokens(tokens);
    console.log('Access token refreshed and saved.');
    return tokens.access_token;
  }
  return tokens.access_token;
}

// ==== ROUTES ====
app.use(express.json());

// 1. OAuth: Exchange code for tokens and auto-write tokens.json
app.post('/api/token', async (req, res) => {
  try {
    const { code } = req.body;
    if (!code) return res.status(400).json({ error: "Authorization code is required" });

    const resp = await axios.post('https://www.strava.com/oauth/token', {
      client_id: process.env.STRAVA_CLIENT_ID,
      client_secret: process.env.STRAVA_CLIENT_SECRET,
      code,
      grant_type: 'authorization_code'
    });

    // Save to tokens.json immediately!
    const toSave = {
      access_token: resp.data.access_token,
      refresh_token: resp.data.refresh_token,
      expires_at: resp.data.expires_at
    };
    saveTokens(toSave);

    res.json(resp.data);
  } catch (e) {
    console.error("Error exchanging token:", e.response?.data || e.message);
    res.status(500).json({ error: e.response?.data || e.message });
  }
});

// 2. Get activities (50 most recent)
app.get('/api/activities', async (req, res) => {
  try {
    const token = await getFreshAccessToken();
    const response = await axios.get('https://www.strava.com/api/v3/athlete/activities', {
      headers: { Authorization: `Bearer ${token}` },
      params: { per_page: 50 }
    });
    res.json(response.data);
  } catch (e) {
    console.error("Error loading activities:", e.response?.data || e.message);
    res.status(500).json({ error: e.response?.data || e.message });
  }
});

// 3. Manual rename endpoint
app.put('/api/rename', async (req, res) => {
  try {
    const token = await getFreshAccessToken();
    const { activityId } = req.body;
    if (!activityId) return res.status(400).json({ error: "ActivityId is required" });

    if (!dialogues.length) return res.status(500).json({ error: "No dialogues available." });

    const d = dialogues[Math.floor(Math.random() * dialogues.length)];
    const name = d.dialogue;
    const description = `— ${d.movie} (${d.year})\n${defaultDescription}`;

    const response = await axios.put(`https://www.strava.com/api/v3/activities/${activityId}`,
      { name, description },
      { headers: { Authorization: `Bearer ${token}` } }
    );

    res.json(response.data);
  } catch (e) {
    console.error("Error renaming activity:", e.response?.data || e.message);
    res.status(500).json({ error: e.response?.data || e.message });
  }
});

// 4. Add dialogue
app.post('/api/add-dialogue', (req, res) => {
  const { dialogue, movie, year } = req.body;
  if (!dialogue || !dialogue.trim()) return res.status(400).json({ error: "Dialogue text is required" });
  if (!movie || !movie.trim()) return res.status(400).json({ error: "Movie name is required" });
  if (!year || !Number.isInteger(year)) return res.status(400).json({ error: "Valid release year is required (integer)" });

  const exists = dialogues.find(d => d.dialogue.toLowerCase() === dialogue.trim().toLowerCase());
  if (exists) return res.status(409).json({ error: "Dialogue already exists" });

  const newEntry = {
    dialogue: dialogue.trim(),
    movie: movie.trim(),
    year
  };

  dialogues.push(newEntry);
  saveDialogues();

  res.json({ success: true, dialogue: newEntry, totalDialogues: dialogues.length });
});

// 5. Get default description
app.get('/api/default-description', (req, res) => {
  res.json({ description: defaultDescription });
});

// 6. Update default description
app.post('/api/update-description', (req, res) => {
  const { description } = req.body;
  if (!description || !description.trim()) return res.status(400).json({ error: "Description text is required" });

  defaultDescription = description.trim();
  res.json({ success: true, description: defaultDescription });
});

// 7. Manual trigger: auto-renames recent activities with generic name
app.post('/api/auto-rename', async (req, res) => {
  try {
    const token = await getFreshAccessToken();
    const activitiesRes = await axios.get('https://www.strava.com/api/v3/athlete/activities', {
      headers: { Authorization: `Bearer ${token}` },
      params: { per_page: 30 }
    });

    const activities = activitiesRes.data;
    const renamedActivities = [];

    for (const activity of activities) {
      if (defaultActivityNames.includes(activity.name)) {
        if (!dialogues.length) continue;
        const d = dialogues[Math.floor(Math.random() * dialogues.length)];
        const name = d.dialogue;
        const description = `— ${d.movie} (${d.year})\n${defaultDescription}`;

        await axios.put(
          `https://www.strava.com/api/v3/activities/${activity.id}`,
          { name, description },
          { headers: { Authorization: `Bearer ${token}` } }
        );

        renamedActivities.push({ id: activity.id, oldName: activity.name, newName: name });
      }
    }
    res.json({ success: true, renamed: renamedActivities });
  } catch (e) {
    console.error("Error auto-renaming activities:", e.response?.data || e.message);
    res.status(500).json({ error: e.response?.data || e.message });
  }
});

// ========== Strava Webhook Verification ================
const VERIFY_TOKEN = process.env.VERIFY_TOKEN || 'your_secret_verify_token';

app.get('/webhook', (req, res) => {
  const mode = req.query['hub.mode'];
  const token = req.query['hub.verify_token'];
  const challenge = req.query['hub.challenge'];

  if (mode === 'subscribe' && token === VERIFY_TOKEN) {
    res.status(200).json({ "hub.challenge": challenge });
  } else {
    res.status(403).send('Forbidden');
  }
});

// ========== Strava Webhook Event Handler (auto-rename from webhook) ============

const athleteId = Number(process.env.STRAVA_ATHLETE_ID);

app.post('/webhook', async (req, res) => {
  res.status(200).send('EVENT_RECEIVED');
  const { aspect_type, object_type, object_id, owner_id } = req.body;

  if (object_type === 'activity' && aspect_type === 'create' && Number(owner_id) === athleteId) {
    try {
      await new Promise(resolve => setTimeout(resolve, 2000)); // brief wait for activity to appear
      const token = await getFreshAccessToken();

      const activityRes = await axios.get(`https://www.strava.com/api/v3/activities/${object_id}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );

      const activity = activityRes.data;
      if (defaultActivityNames.includes(activity.name)) {
        if (!dialogues.length) return;

        const d = dialogues[Math.floor(Math.random() * dialogues.length)];
        const name = d.dialogue;
        const description = `— ${d.movie} (${d.year})\n${defaultDescription}`;

        await axios.put(`https://www.strava.com/api/v3/activities/${object_id}`,
          { name, description },
          { headers: { Authorization: `Bearer ${token}` } }
        );
        console.log(`Auto-renamed new activity ${object_id} from "${activity.name}" to "${name}"`);
      }
    } catch (err) {
      console.error('Error auto-renaming webhook activity:', err.response?.data || err.message);
    }
  }
});

// ========= START SERVER =========
app.listen(PORT, '0.0.0.0', () => {
  console.log(`Server listening on port ${PORT}`);
});
